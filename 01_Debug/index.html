<!DOCTYPE html>
<html>
<head>
  <meta>
  <title>test</title>
  <!-- 多次元配列を一次元に変換する処理を行い、その結果をWebページに表示するサンプル -->
  <script type="text/javascript">
    function toOneDimension(previousValue, currentValue) {
      // return previousValue.concat(currentValue);
      // concatメソッドは2以上の配列を結合して新しい配列を作る
      // ２次元目の配列を結合して新しく配列を作っている
      // previousValue(第一引数)：currentValueよりもひとつ前の要素（前回の処理結果）
      // currentValue(第二引数)：現在処理されている要素


      // // 各サブ配列を逆順に結合
      return currentValue.concat(previousValue);
      // こちらのコード行では、previousValue が先に、currentValue が後になるように配列を結合しています。zつまり前回までの処理結果が現在の要素の後ろに結合されます。
    }
    // console.log(toOneDimension);

    // 多次元配列(配列の中にさらに配列がはいっている状態)を表しています。各要素は3つの文字列からなるサブ配列
    var sampleArrayA = [
      ['A1', 'A2', 'A3'],
      ['B1', 'B2', 'B3'],
      ['C1', 'C2', 'C3']
    ];
    // １次元目の配列
    console.log(sampleArrayA);

    var sampleArrayB = sampleArrayA.reduce(toOneDimension);
    // reduce メソッドを使って、sampleArrayA を toOneDimension 関数（concatメソッド）を用いて一次元の配列に変換します。sampleArrayB はこの一次元の配列です。
    // サブ配列
    console.log(sampleArrayB);
    for (var counterVar = 0; counterVar < sampleArrayB.length; counterVar++) {
      // ページに表示するための文字列を書き出し
      document.write('sampleArrayB[' + counterVar + ']: ');
      // sampleArrayB の現在の要素を書き出します。
      document.write(sampleArrayB[counterVar]);
      // 改行を追加して、次の要素が新しい行に表示
      document.write('<br />');
    }
  </script>
</head>
<body>
  <!-- return currentValue.concat(previousValue); -->
  <!-- ここでは currentValue と previousValue が引数として与えられ、これらは Array.reduce メソッドによって順次取得される配列要素です。 -->
  <!-- currentValue: 現在の要素（サブ配列）です。 -->
  <!-- previousValue: これまでの処理で生成された結果（結合された一次元配列）です。 -->
  <!-- concat メソッドは、元の配列に新しい要素を追加して新しい配列を作成します。この場合、currentValue は前回までの処理で作成された配列であり、previousValue は現在のサブ配列です。concat を使ってこれらを逆順に結合しているため、新しい一次元の配列ができます。

簡単に言えば、toOneDimension 関数は、配列を一次元に変換するために、各サブ配列を逆順に結合しています。 -->

  <!-- var sampleArrayB = sampleArrayA.reduce(toOneDimension); -->
  <!-- 「reduce()」は、配列を反復処理するメソッド reduce()は対象となる配列に対して任意の関数を実行することができます。-->
  <!-- 配列.reduce(function(累積値, 要素) { }) -->

  <!-- 第1引数の「累積値」コールバック関数には、配列要素を順番に処理していった値が格納されます。第2引数の「要素」初期値 は現在処理されている配列要素を意味しています。この関数内で「return」を使い、任意の処理を返すことで累積値に結果が保持されて最終的に1つの値となって取得できるわけです。 -->

  <!-- alert()
  console.log() -->

</body>
</html>
